<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title th:text="#{page.title}">Reitti - Your Location Timeline</title>
    <link rel="stylesheet" href="/css/leaflet.css">
    <link rel="stylesheet" href="/css/date-picker.css">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/lineicons.css">
    <link rel="stylesheet" href="/css/photo-client.css">
    <link rel="stylesheet" href="/css/inline-edit.css">
    <script src="/js/HumanizeDuration.js"></script>
    <script src="/js/horizontal-date-picker.js"></script>
    <script src="/js/timeline-scroll-indicator.js"></script>
    <script src="/js/photo-client.js"></script>
    <script src="/js/htmx.min.js"></script>
    <script src="/js/leaflet.js"></script>
    <script src="/js/TileLayer.Grayscale.js"></script>
</head>
<body>
<div id="map"></div>



<div class="timeline">
    <div class="timeline-header">
        <span><img class="logo" th:src="@{/img/logo.png}" alt="reitti logo" title="reitti" src="/img/logo.png"></span>
        <a href="/statistics" class="nav-link" th:title="#{nav.statistics}"><i class="lni lni-bar-chart-4"></i></a>
        <a href="/settings" class="nav-link" th:title="#{nav.settings.tooltip}"><i class="lni lni-gear-1"></i></a>
        <form th:action="@{/logout}" method="post" >
            <button type="submit" class="nav-link" style="font-size: 1.4rem;" th:title="#{nav.logout.tooltip}"><i
                    class="lni lni-exit"></i>
            </button>
        </form>
    </div>
    <div class="timeline-container" 
         hx-get="/timeline/content"
         hx-trigger="load, dateChanged from:body"
         hx-vals='js:{"date": getSelectedDate(), "timezone": getUserTimezone()}'
         hx-indicator="#loading-indicator">
        <div id="loading-indicator" class="timeline-entry" th:text="#{timeline.loading}">Loading...</div>
    </div>
</div>

<!-- Horizontal date picker will be initialized here -->
<div id="horizontal-date-picker-container"></div>

<script th:inline="javascript">
    // Locale object for JavaScript
    window.locale = {
        loading: /*[[#{timeline.loading}]]*/ 'Loading...',
        noData: /*[[#{timeline.no.data}]]*/ 'No timeline data available for this date.',
        duration: /*[[#{timeline.duration}]]*/ 'Duration',
        distance: /*[[#{timeline.distance}]]*/ 'Distance',
        trip: /*[[#{timeline.trip}]]*/ 'Trip',
        transportWalking: /*[[#{timeline.transport.walking}]]*/ 'by foot',
        transportCycling: /*[[#{timeline.transport.cycling}]]*/ 'by bike',
        transportDriving: /*[[#{timeline.transport.driving}]]*/ 'by car',
        today: /*[[#{datepicker.today}]]*/ 'Today',
        days: [
            /*[[#{datepicker.days.sun}]]*/ 'Sun',
            /*[[#{datepicker.days.mon}]]*/ 'Mon',
            /*[[#{datepicker.days.tue}]]*/ 'Tue',
            /*[[#{datepicker.days.wed}]]*/ 'Wed',
            /*[[#{datepicker.days.thu}]]*/ 'Thu',
            /*[[#{datepicker.days.fri}]]*/ 'Fri',
            /*[[#{datepicker.days.sat}]]*/ 'Sat'
        ],
        months: [
            /*[[#{datepicker.months.jan}]]*/ 'Jan',
            /*[[#{datepicker.months.feb}]]*/ 'Feb',
            /*[[#{datepicker.months.mar}]]*/ 'Mar',
            /*[[#{datepicker.months.apr}]]*/ 'Apr',
            /*[[#{datepicker.months.may}]]*/ 'May',
            /*[[#{datepicker.months.jun}]]*/ 'Jun',
            /*[[#{datepicker.months.jul}]]*/ 'Jul',
            /*[[#{datepicker.months.aug}]]*/ 'Aug',
            /*[[#{datepicker.months.sep}]]*/ 'Sep',
            /*[[#{datepicker.months.oct}]]*/ 'Oct',
            /*[[#{datepicker.months.nov}]]*/ 'Nov',
            /*[[#{datepicker.months.dec}]]*/ 'Dec'
        ]
    };
    
    // Set locale for HumanizeDuration
    const currentLocale = /*[[${#locale.language}]]*/ 'en';

    // Helper function for HTMX to get current selected date
    function getSelectedDate() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('date') || new Date().toISOString().split('T')[0];
    }

    // Helper function for HTMX to get user timezone
    function getUserTimezone() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }

    const fitToBoundsConfig = {
        paddingTopLeft: [100,0],
        paddingBottomRight: [100, 300],
        zoomSnap: 0.1
    };


    document.addEventListener('DOMContentLoaded', function () {


        // Check if date is in URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        let initialDate;

        if (urlParams.has('date')) {
            initialDate = urlParams.get('date');
            // Validate date format (YYYY-MM-DD)
            if (!/^\d{4}-\d{2}-\d{2}$/.test(initialDate)) {
                initialDate = null;
            }
        }

        // Set date picker to URL date or today's date
        const today = new Date();
        const formattedDate = initialDate || today.toISOString().split('T')[0]; // YYYY-MM-DD format

        // Function to update URL with date parameter
        function updateUrlWithDate(date) {
            const url = new URL(window.location);
            url.searchParams.set('date', date);
            window.history.pushState({}, '', url);
        }

        // Initialize the map
        const map = L.map('map', {zoomControl: false, attributionControl: false}).setView([60.1699, 24.9384], 12); // Helsinki coordinates as default
        L.tileLayer.grayscale('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
        }).addTo(map);

        L.control.attribution({position: 'topright'}).addAttribution('&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>')
            .addTo(map)

        // Initialize photo client
        const photoClient = new PhotoClient(map);
        
        // Listen for map move/zoom events to update photo markers
        map.on('moveend zoomend', () => {
            photoClient.onMapMoveEnd();
        });

        function loadTimelineData(date) {
            // Load photos for the selected date
            photoClient.updatePhotosForDate(date, getUserTimezone());

            // Fetch raw location points for map display
            fetch(`/api/v1/raw-location-points?date=${date}&timezone=${getUserTimezone()}`).then(response => {
                if (!response.ok) {
                    console.warn('Could not fetch raw location points');
                    return { points: [] };
                }
                return response.json();
            }).then(rawPointsData => {
                updateMapWithRawPoints(rawPointsData);
            }).catch(error => {
                console.warn('Error fetching raw location points:', error);
            });
        }

        // Function to update map with raw location points
        function updateMapWithRawPoints(rawPointsData) {
            // Remove existing raw points path
            rawPointsPath.remove();

            // Add raw location points if available
            if (rawPointsData && rawPointsData.points && rawPointsData.points.length > 0) {
                const rawPointsCoords = rawPointsData.points.map(point => [point.latitude, point.longitude]);
                rawPointsPath.setLatLngs(rawPointsCoords);
                rawPointsPath.addTo(map);
                map.fitBounds(rawPointsCoords, fitToBoundsConfig)
            }
        }

        const selectedPath = L.polyline([], {
            color: '#ff984f',
            weight: 6,
            opacity: 1,
            lineJoin: 'round',
            lineCap: 'round'
        });

        // Create a polyline for raw location points
        const rawPointsPath = L.polyline([], {
            color: '#f1ba63',  // Purple color for raw points
            weight: 6,
            opacity: 0.9,
            lineJoin: 'round',
            lineCap: 'round'
        });


        // Add HTMX event handlers for timeline updates
        document.body.addEventListener('htmx:afterSwap', function(event) {
            if (event.detail.target.classList.contains('timeline-container')) {
                // Timeline content has been updated, update map markers
                updateMapFromTimeline();
                loadTimelineData(getSelectedDate())
                // Initialize scroll indicator after timeline is updated
                if (window.timelineScrollIndicator) {
                    window.timelineScrollIndicator.cleanup();
                }
                window.timelineScrollIndicator = new TimelineScrollIndicator();
                window.timelineScrollIndicator.init();
            }
        });

        // Function to update map markers from timeline entries
        function updateMapFromTimeline() {
            // Clear existing markers and paths (except tile layer)
            map.eachLayer(layer => {
                if (!layer._url) {
                    map.removeLayer(layer);
                }
            });

            const bounds = L.latLngBounds();
            window.originalBounds = L.latLngBounds();
            let hasValidCoords = false;

            // Group places by coordinates to avoid duplicate markers
            const placeGroups = new Map();

            // Get all timeline entries from the DOM
            const timelineEntries = document.querySelectorAll('.timeline-entry[data-lat][data-lng]');
            
            timelineEntries.forEach(entryElement => {
                const lat = parseFloat(entryElement.dataset.lat);
                const lng = parseFloat(entryElement.dataset.lng);
                
                if (!isNaN(lat) && !isNaN(lng) && entryElement.classList.contains('visit')) {
                    const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;
                    
                    if (!placeGroups.has(coordKey)) {
                        // Extract place name from the timeline entry
                        const placeNameElement = entryElement.querySelector('.place-name');
                        const placeName = placeNameElement ? placeNameElement.textContent : 'Unknown Place';
                        
                        placeGroups.set(coordKey, {
                            lat: lat,
                            lng: lng,
                            totalDurationMs: 0,
                            visits: [],
                            place: { name: placeName, address: '' }
                        });
                    }
                    
                    const group = placeGroups.get(coordKey);
                    // Calculate duration from time range text
                    const durationElement = entryElement.querySelector('.entry-duration');
                    if (durationElement) {
                        const durationText = durationElement.textContent;
                        const durationMs = parseDurationText(durationText);
                        group.totalDurationMs += durationMs;
                    }
                    group.visits.push({ id: entryElement.dataset.id });
                    
                    bounds.extend([lat, lng]);
                    window.originalBounds.extend([lat, lng]);
                    hasValidCoords = true;
                }
            });

            // Draw markers for grouped places
            placeGroups.forEach((group, coordKey) => {
                const { lat, lng, totalDurationMs, visits, place } = group;
                
                // Calculate radius using logarithmic scale
                const durationHours = totalDurationMs / (1000 * 60 * 60);
                const baseRadius = 15;
                const maxRadius = 100;
                const minRadius = 15;
                
                const logScale = Math.log(1 + durationHours) / Math.log(1 + 24);
                const radius = Math.min(maxRadius, Math.max(minRadius, baseRadius + (logScale * (maxRadius - baseRadius))));

                // Create marker
                L.circleMarker([lat, lng], {
                    radius: 5,
                    fillColor: '#ff6c00',
                    color: '#fff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map);

                // Create circle with calculated radius
                const circle = L.circle([lat, lng], {
                    color: '#dcae4a',
                    fillColor: '#ff984f',
                    fillOpacity: 0.1,
                    radius: radius
                }).addTo(map);

                const totalDurationText = humanizeDuration(totalDurationMs, {units: ["h", "m"], round: true});
                const visitCount = visits.length;
                const visitText = visitCount === 1 ? 'visit' : 'visits';
                
                let tooltip = L.tooltip([lat, lng], {
                    content: `<div style="font-size: 1.4rem; color: wheat">${place.name}</div>
                             <div style="margin-top: 4px; font-weight: bold;">
                                 ${visitCount} ${visitText} - Total: ${totalDurationText}
                             </div>`,
                    className: 'visit-popup', 
                    permanent: false
                });

                circle.bindTooltip(tooltip);
            });

            // Fit map to bounds if we have valid coordinates
            if (hasValidCoords) {
                map.fitBounds(bounds, fitToBoundsConfig);
            }
        }

        // Helper function to parse duration text (simple implementation)
        function parseDurationText(durationText) {
            // Extract numbers followed by 'h' or 'm'
            const hours = (durationText.match(/(\d+)h/) || [0, 0])[1];
            const minutes = (durationText.match(/(\d+)m/) || [0, 0])[1];
            return (parseInt(hours) * 60 + parseInt(minutes)) * 60 * 1000; // Convert to milliseconds
        }

        // Handle clicks on timeline entries
        document.querySelector('.timeline-container').addEventListener('click', function (event) {
            const entry = event.target.closest('.timeline-entry');
            if (!entry) return;

            const editingElement = event.target.closest('.editing');
            if (editingElement || event.target.classList.contains('edit-icon')) {
                return;
            }
            // Check if this entry is already active (deselection case)
            const isCurrentlyActive = entry.classList.contains('active');
            
            // Remove active class from all entries
            document.querySelectorAll('.timeline-container .timeline-entry')
                .forEach(e => e.classList.remove('active'));
            
            // Remove any selected path
            selectedPath.remove();
            
            if (isCurrentlyActive) {
                // Deselection: zoom back to original bounds showing all data
                if (window.originalBounds && window.originalBounds.isValid()) {
                    map.flyToBounds(window.originalBounds, fitToBoundsConfig);
                }
            } else {
                // Selection: zoom to specific entry
                entry.classList.add('active');
                const newBounds = L.latLngBounds();

                const lat = parseFloat(entry.dataset.lat);
                const lng = parseFloat(entry.dataset.lng);

                if (entry.dataset.path) {
                    const pathData = JSON.parse(entry.dataset.path);
                    const latlngs = pathData.map(coord => [coord.latitude, coord.longitude]);
                    latlngs.forEach(latlng => {
                        newBounds.extend(latlng);
                    });
                    selectedPath.setLatLngs(latlngs);
                    selectedPath.addTo(map);
                }
                    
                if (!isNaN(lat) && !isNaN(lng)) {
                    newBounds.extend([lat, lng]);
                }
                    
                if (newBounds.isValid()) {
                    map.flyToBounds(newBounds, fitToBoundsConfig);
                }
            }
        });

        // Load initial timeline data via HTMX (will be triggered by the hx-trigger="load")
        // Also load photos and raw points for the initial date
        loadTimelineData(formattedDate);

        // Parse the initial date properly to ensure correct date picker initialization
        let dateToUse = new Date();
        if (initialDate) {
            // Parse the date from URL parameter (YYYY-MM-DD format)
            const [year, month, day] = initialDate.split('-').map(Number);
            // Note: month is 0-indexed in JavaScript Date
            dateToUse = new Date(year, month - 1, day);
        }

        // Initialize horizontal date picker
        new HorizontalDatePicker({
            container: document.getElementById('horizontal-date-picker-container'),
            selectedDate: dateToUse,
            showNavButtons: false, // Show navigation buttons
            daysToShow: 21, // Show more days
            showMonthRow: true, // Enable month selection row
            showYearRow: true, // Enable year selection row
            yearsToShow: 5, // Show 5 years in the year row
            allowFutureDates: false, // Disable selection of future dates
            showTodayButton: true, // Show the Today button
            // No min/max date for infinite scrolling
            onDateSelect: (date, formattedDate) => {
                // Update URL
                updateUrlWithDate(formattedDate);
                // Trigger HTMX reload of timeline
                document.body.dispatchEvent(new CustomEvent('dateChanged'));
            },
            onDateDeselect: () => {
                // Clear photos when no date is selected
                photoClient.clearPhotos();
            }
        });
    });
</script>
</body>
</html>
